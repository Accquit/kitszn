
-- Drop existing table and type to ensure a clean slate.
DROP TABLE IF EXISTS public.user_roles;
DROP TYPE IF EXISTS public.app_role;

-- Step 1: Create an enum for user roles.
CREATE TYPE public.app_role AS ENUM ('admin', 'user');

-- Step 2: Create the user_roles table.
CREATE TABLE public.user_roles (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    role public.app_role NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    UNIQUE(user_id, role)
);
COMMENT ON TABLE public.user_roles IS 'Stores roles for each user, linking them to auth.users.';

-- Step 3: Create a helper function to check for admin role.
-- This function is defined with SECURITY DEFINER to safely check roles
-- without being blocked by RLS policies.
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
    -- Check if a user is logged in
    IF auth.uid() IS NULL THEN
        RETURN FALSE;
    END IF;

    -- Check if the user has the 'admin' role
    RETURN EXISTS (
        SELECT 1
        FROM public.user_roles
        WHERE user_id = auth.uid() AND role = 'admin'
    );
END;
$$;

-- Step 4: Secure the user_roles table with RLS.
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins can manage all roles"
ON public.user_roles
FOR ALL
USING (public.is_admin());

CREATE POLICY "Users can view their own roles"
ON public.user_roles
FOR SELECT
USING (auth.uid() = user_id);

-- Step 5: Secure the profiles table with RLS.
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage their own profile"
ON public.profiles
FOR ALL
USING (id = auth.uid());

CREATE POLICY "Admins can manage all profiles"
ON public.profiles
FOR ALL
USING (public.is_admin());
